/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 35.1.0 Mon Jul 20 13:46:32 2020.
 */

#ifndef LKA_DBC_0_96_H
#define LKA_DBC_0_96_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define LKA_DBC_0_96_NEXT_LANE_B_8_FRAME_ID (0x77du)
#define LKA_DBC_0_96_NEXT_LANE_B_7_FRAME_ID (0x77bu)
#define LKA_DBC_0_96_NEXT_LANE_B_6_FRAME_ID (0x779u)
#define LKA_DBC_0_96_NEXT_LANE_B_5_FRAME_ID (0x777u)
#define LKA_DBC_0_96_NEXT_LANE_B_4_FRAME_ID (0x775u)
#define LKA_DBC_0_96_NEXT_LANE_B_3_FRAME_ID (0x773u)
#define LKA_DBC_0_96_NEXT_LANE_B_2_FRAME_ID (0x771u)
#define LKA_DBC_0_96_NEXT_LANE_B_1_FRAME_ID (0x76fu)
#define LKA_DBC_0_96_NEXT_LANE_B_FRAME_ID (0x76du)
#define LKA_DBC_0_96_NEXT_LANE_A_8_FRAME_ID (0x77cu)
#define LKA_DBC_0_96_NEXT_LANE_A_7_FRAME_ID (0x77au)
#define LKA_DBC_0_96_NEXT_LANE_A_6_FRAME_ID (0x778u)
#define LKA_DBC_0_96_NEXT_LANE_A_5_FRAME_ID (0x776u)
#define LKA_DBC_0_96_NEXT_LANE_A_4_FRAME_ID (0x774u)
#define LKA_DBC_0_96_NEXT_LANE_A_3_FRAME_ID (0x772u)
#define LKA_DBC_0_96_NEXT_LANE_A_2_FRAME_ID (0x770u)
#define LKA_DBC_0_96_NEXT_LANE_A_1_FRAME_ID (0x76eu)
#define LKA_DBC_0_96_NEXT_LANE_A_FRAME_ID (0x76cu)
#define LKA_DBC_0_96_NUM_OF_NEXT_LANE_MARKS_REPORTED_FRAME_ID (0x76bu)
#define LKA_DBC_0_96_REFERENCE_POINTS_FRAME_ID (0x76au)
#define LKA_DBC_0_96_LKA_RIGHT_LANE_B_FRAME_ID (0x769u)
#define LKA_DBC_0_96_LKA_RIGHT_LANE_A_FRAME_ID (0x768u)
#define LKA_DBC_0_96_LKA_LEFT_LANE_B_FRAME_ID (0x767u)
#define LKA_DBC_0_96_LKA_LEFT_LANE_A_FRAME_ID (0x766u)

/* Frame lengths in bytes. */
#define LKA_DBC_0_96_NEXT_LANE_B_8_LENGTH (4u)
#define LKA_DBC_0_96_NEXT_LANE_B_7_LENGTH (4u)
#define LKA_DBC_0_96_NEXT_LANE_B_6_LENGTH (4u)
#define LKA_DBC_0_96_NEXT_LANE_B_5_LENGTH (4u)
#define LKA_DBC_0_96_NEXT_LANE_B_4_LENGTH (4u)
#define LKA_DBC_0_96_NEXT_LANE_B_3_LENGTH (4u)
#define LKA_DBC_0_96_NEXT_LANE_B_2_LENGTH (4u)
#define LKA_DBC_0_96_NEXT_LANE_B_1_LENGTH (4u)
#define LKA_DBC_0_96_NEXT_LANE_B_LENGTH (4u)
#define LKA_DBC_0_96_NEXT_LANE_A_8_LENGTH (8u)
#define LKA_DBC_0_96_NEXT_LANE_A_7_LENGTH (8u)
#define LKA_DBC_0_96_NEXT_LANE_A_6_LENGTH (8u)
#define LKA_DBC_0_96_NEXT_LANE_A_5_LENGTH (8u)
#define LKA_DBC_0_96_NEXT_LANE_A_4_LENGTH (8u)
#define LKA_DBC_0_96_NEXT_LANE_A_3_LENGTH (8u)
#define LKA_DBC_0_96_NEXT_LANE_A_2_LENGTH (8u)
#define LKA_DBC_0_96_NEXT_LANE_A_1_LENGTH (8u)
#define LKA_DBC_0_96_NEXT_LANE_A_LENGTH (8u)
#define LKA_DBC_0_96_NUM_OF_NEXT_LANE_MARKS_REPORTED_LENGTH (1u)
#define LKA_DBC_0_96_REFERENCE_POINTS_LENGTH (8u)
#define LKA_DBC_0_96_LKA_RIGHT_LANE_B_LENGTH (4u)
#define LKA_DBC_0_96_LKA_RIGHT_LANE_A_LENGTH (8u)
#define LKA_DBC_0_96_LKA_LEFT_LANE_B_LENGTH (4u)
#define LKA_DBC_0_96_LKA_LEFT_LANE_A_LENGTH (8u)

/* Extended or standard frame types. */
#define LKA_DBC_0_96_NEXT_LANE_B_8_IS_EXTENDED (0)
#define LKA_DBC_0_96_NEXT_LANE_B_7_IS_EXTENDED (0)
#define LKA_DBC_0_96_NEXT_LANE_B_6_IS_EXTENDED (0)
#define LKA_DBC_0_96_NEXT_LANE_B_5_IS_EXTENDED (0)
#define LKA_DBC_0_96_NEXT_LANE_B_4_IS_EXTENDED (0)
#define LKA_DBC_0_96_NEXT_LANE_B_3_IS_EXTENDED (0)
#define LKA_DBC_0_96_NEXT_LANE_B_2_IS_EXTENDED (0)
#define LKA_DBC_0_96_NEXT_LANE_B_1_IS_EXTENDED (0)
#define LKA_DBC_0_96_NEXT_LANE_B_IS_EXTENDED (0)
#define LKA_DBC_0_96_NEXT_LANE_A_8_IS_EXTENDED (0)
#define LKA_DBC_0_96_NEXT_LANE_A_7_IS_EXTENDED (0)
#define LKA_DBC_0_96_NEXT_LANE_A_6_IS_EXTENDED (0)
#define LKA_DBC_0_96_NEXT_LANE_A_5_IS_EXTENDED (0)
#define LKA_DBC_0_96_NEXT_LANE_A_4_IS_EXTENDED (0)
#define LKA_DBC_0_96_NEXT_LANE_A_3_IS_EXTENDED (0)
#define LKA_DBC_0_96_NEXT_LANE_A_2_IS_EXTENDED (0)
#define LKA_DBC_0_96_NEXT_LANE_A_1_IS_EXTENDED (0)
#define LKA_DBC_0_96_NEXT_LANE_A_IS_EXTENDED (0)
#define LKA_DBC_0_96_NUM_OF_NEXT_LANE_MARKS_REPORTED_IS_EXTENDED (0)
#define LKA_DBC_0_96_REFERENCE_POINTS_IS_EXTENDED (0)
#define LKA_DBC_0_96_LKA_RIGHT_LANE_B_IS_EXTENDED (0)
#define LKA_DBC_0_96_LKA_RIGHT_LANE_A_IS_EXTENDED (0)
#define LKA_DBC_0_96_LKA_LEFT_LANE_B_IS_EXTENDED (0)
#define LKA_DBC_0_96_LKA_LEFT_LANE_A_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */
#define LKA_DBC_0_96_NEXT_LANE_B_8_VIEW_RANGE_AVAILABILITY_NOT__VALID_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_B_8_VIEW_RANGE_AVAILABILITY_VALID_CHOICE (1u)

#define LKA_DBC_0_96_NEXT_LANE_B_7_VIEW_RANGE_AVAILABILITY_NOT__VALID_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_B_7_VIEW_RANGE_AVAILABILITY_VALID_CHOICE (1u)

#define LKA_DBC_0_96_NEXT_LANE_B_6_VIEW_RANGE_AVAILABILITY_NOT__VALID_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_B_6_VIEW_RANGE_AVAILABILITY_VALID_CHOICE (1u)

#define LKA_DBC_0_96_NEXT_LANE_B_5_VIEW_RANGE_AVAILABILITY_NOT__VALID_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_B_5_VIEW_RANGE_AVAILABILITY_VALID_CHOICE (1u)

#define LKA_DBC_0_96_NEXT_LANE_B_4_VIEW_RANGE_AVAILABILITY_NOT__VALID_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_B_4_VIEW_RANGE_AVAILABILITY_VALID_CHOICE (1u)

#define LKA_DBC_0_96_NEXT_LANE_B_3_VIEW_RANGE_AVAILABILITY_NOT__VALID_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_B_3_VIEW_RANGE_AVAILABILITY_VALID_CHOICE (1u)

#define LKA_DBC_0_96_NEXT_LANE_B_2_VIEW_RANGE_AVAILABILITY_NOT__VALID_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_B_2_VIEW_RANGE_AVAILABILITY_VALID_CHOICE (1u)

#define LKA_DBC_0_96_NEXT_LANE_B_1_VIEW_RANGE_AVAILABILITY_NOT__VALID_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_B_1_VIEW_RANGE_AVAILABILITY_VALID_CHOICE (1u)

#define LKA_DBC_0_96_NEXT_LANE_B_VIEW_RANGE_AVAILABILITY_NOT__VALID_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_B_VIEW_RANGE_AVAILABILITY_VALID_CHOICE (1u)

#define LKA_DBC_0_96_NEXT_LANE_A_8_LANE_TYPE_DASHED_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_8_LANE_TYPE_SOLID_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_8_LANE_TYPE_UNDECIDED_CHOICE (2u)
#define LKA_DBC_0_96_NEXT_LANE_A_8_LANE_TYPE_ROAD__EDGE_CHOICE (3u)
#define LKA_DBC_0_96_NEXT_LANE_A_8_LANE_TYPE_DOUBLE__LANE_CHOICE (4u)
#define LKA_DBC_0_96_NEXT_LANE_A_8_LANE_TYPE_BOTT_S__DOTS_CHOICE (5u)
#define LKA_DBC_0_96_NEXT_LANE_A_8_LANE_TYPE_INVALID_CHOICE (6u)

#define LKA_DBC_0_96_NEXT_LANE_A_8_QUALITY_LOW_QUALITY_0_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_8_QUALITY_LOW_QUALITY_1_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_8_QUALITY_HIGH_QUALITY_2_CHOICE (2u)
#define LKA_DBC_0_96_NEXT_LANE_A_8_QUALITY_HIGH_QUALITY_3_CHOICE (3u)

#define LKA_DBC_0_96_NEXT_LANE_A_8_MODEL_DEGREE_PARABOLIC_MODEL_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_8_MODEL_DEGREE_LINEAR_MODEL_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_8_MODEL_DEGREE_3RD_DEGREE_MODEL_CHOICE (2u)

#define LKA_DBC_0_96_NEXT_LANE_A_7_LANE_TYPE_DASHED_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_7_LANE_TYPE_SOLID_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_7_LANE_TYPE_UNDECIDED_CHOICE (2u)
#define LKA_DBC_0_96_NEXT_LANE_A_7_LANE_TYPE_ROAD__EDGE_CHOICE (3u)
#define LKA_DBC_0_96_NEXT_LANE_A_7_LANE_TYPE_DOUBLE__LANE_CHOICE (4u)
#define LKA_DBC_0_96_NEXT_LANE_A_7_LANE_TYPE_BOTT_S__DOTS_CHOICE (5u)
#define LKA_DBC_0_96_NEXT_LANE_A_7_LANE_TYPE_INVALID_CHOICE (6u)

#define LKA_DBC_0_96_NEXT_LANE_A_7_QUALITY_LOW_QUALITY_0_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_7_QUALITY_LOW_QUALITY_1_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_7_QUALITY_HIGH_QUALITY_2_CHOICE (2u)
#define LKA_DBC_0_96_NEXT_LANE_A_7_QUALITY_HIGH_QUALITY_3_CHOICE (3u)

#define LKA_DBC_0_96_NEXT_LANE_A_7_MODEL_DEGREE_PARABOLIC_MODEL_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_7_MODEL_DEGREE_LINEAR_MODEL_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_7_MODEL_DEGREE_3RD_DEGREE_MODEL_CHOICE (2u)

#define LKA_DBC_0_96_NEXT_LANE_A_6_LANE_TYPE_DASHED_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_6_LANE_TYPE_SOLID_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_6_LANE_TYPE_UNDECIDED_CHOICE (2u)
#define LKA_DBC_0_96_NEXT_LANE_A_6_LANE_TYPE_ROAD__EDGE_CHOICE (3u)
#define LKA_DBC_0_96_NEXT_LANE_A_6_LANE_TYPE_DOUBLE__LANE_CHOICE (4u)
#define LKA_DBC_0_96_NEXT_LANE_A_6_LANE_TYPE_BOTT_S__DOTS_CHOICE (5u)
#define LKA_DBC_0_96_NEXT_LANE_A_6_LANE_TYPE_INVALID_CHOICE (6u)

#define LKA_DBC_0_96_NEXT_LANE_A_6_QUALITY_LOW_QUALITY_0_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_6_QUALITY_LOW_QUALITY_1_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_6_QUALITY_HIGH_QUALITY_2_CHOICE (2u)
#define LKA_DBC_0_96_NEXT_LANE_A_6_QUALITY_HIGH_QUALITY_3_CHOICE (3u)

#define LKA_DBC_0_96_NEXT_LANE_A_6_MODEL_DEGREE_PARABOLIC_MODEL_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_6_MODEL_DEGREE_LINEAR_MODEL_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_6_MODEL_DEGREE_3RD_DEGREE_MODEL_CHOICE (2u)

#define LKA_DBC_0_96_NEXT_LANE_A_5_LANE_TYPE_DASHED_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_5_LANE_TYPE_SOLID_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_5_LANE_TYPE_UNDECIDED_CHOICE (2u)
#define LKA_DBC_0_96_NEXT_LANE_A_5_LANE_TYPE_ROAD__EDGE_CHOICE (3u)
#define LKA_DBC_0_96_NEXT_LANE_A_5_LANE_TYPE_DOUBLE__LANE_CHOICE (4u)
#define LKA_DBC_0_96_NEXT_LANE_A_5_LANE_TYPE_BOTT_S__DOTS_CHOICE (5u)
#define LKA_DBC_0_96_NEXT_LANE_A_5_LANE_TYPE_INVALID_CHOICE (6u)

#define LKA_DBC_0_96_NEXT_LANE_A_5_QUALITY_LOW_QUALITY_0_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_5_QUALITY_LOW_QUALITY_1_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_5_QUALITY_HIGH_QUALITY_2_CHOICE (2u)
#define LKA_DBC_0_96_NEXT_LANE_A_5_QUALITY_HIGH_QUALITY_3_CHOICE (3u)

#define LKA_DBC_0_96_NEXT_LANE_A_5_MODEL_DEGREE_PARABOLIC_MODEL_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_5_MODEL_DEGREE_LINEAR_MODEL_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_5_MODEL_DEGREE_3RD_DEGREE_MODEL_CHOICE (2u)

#define LKA_DBC_0_96_NEXT_LANE_A_4_LANE_TYPE_DASHED_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_4_LANE_TYPE_SOLID_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_4_LANE_TYPE_UNDECIDED_CHOICE (2u)
#define LKA_DBC_0_96_NEXT_LANE_A_4_LANE_TYPE_ROAD__EDGE_CHOICE (3u)
#define LKA_DBC_0_96_NEXT_LANE_A_4_LANE_TYPE_DOUBLE__LANE_CHOICE (4u)
#define LKA_DBC_0_96_NEXT_LANE_A_4_LANE_TYPE_BOTT_S__DOTS_CHOICE (5u)
#define LKA_DBC_0_96_NEXT_LANE_A_4_LANE_TYPE_INVALID_CHOICE (6u)

#define LKA_DBC_0_96_NEXT_LANE_A_4_QUALITY_LOW_QUALITY_0_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_4_QUALITY_LOW_QUALITY_1_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_4_QUALITY_HIGH_QUALITY_2_CHOICE (2u)
#define LKA_DBC_0_96_NEXT_LANE_A_4_QUALITY_HIGH_QUALITY_3_CHOICE (3u)

#define LKA_DBC_0_96_NEXT_LANE_A_4_MODEL_DEGREE_PARABOLIC_MODEL_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_4_MODEL_DEGREE_LINEAR_MODEL_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_4_MODEL_DEGREE_3RD_DEGREE_MODEL_CHOICE (2u)

#define LKA_DBC_0_96_NEXT_LANE_A_3_LANE_TYPE_DASHED_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_3_LANE_TYPE_SOLID_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_3_LANE_TYPE_UNDECIDED_CHOICE (2u)
#define LKA_DBC_0_96_NEXT_LANE_A_3_LANE_TYPE_ROAD__EDGE_CHOICE (3u)
#define LKA_DBC_0_96_NEXT_LANE_A_3_LANE_TYPE_DOUBLE__LANE_CHOICE (4u)
#define LKA_DBC_0_96_NEXT_LANE_A_3_LANE_TYPE_BOTT_S__DOTS_CHOICE (5u)
#define LKA_DBC_0_96_NEXT_LANE_A_3_LANE_TYPE_INVALID_CHOICE (6u)

#define LKA_DBC_0_96_NEXT_LANE_A_3_QUALITY_LOW_QUALITY_0_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_3_QUALITY_LOW_QUALITY_1_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_3_QUALITY_HIGH_QUALITY_2_CHOICE (2u)
#define LKA_DBC_0_96_NEXT_LANE_A_3_QUALITY_HIGH_QUALITY_3_CHOICE (3u)

#define LKA_DBC_0_96_NEXT_LANE_A_3_MODEL_DEGREE_PARABOLIC_MODEL_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_3_MODEL_DEGREE_LINEAR_MODEL_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_3_MODEL_DEGREE_3RD_DEGREE_MODEL_CHOICE (2u)

#define LKA_DBC_0_96_NEXT_LANE_A_2_LANE_TYPE_DASHED_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_2_LANE_TYPE_SOLID_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_2_LANE_TYPE_UNDECIDED_CHOICE (2u)
#define LKA_DBC_0_96_NEXT_LANE_A_2_LANE_TYPE_ROAD__EDGE_CHOICE (3u)
#define LKA_DBC_0_96_NEXT_LANE_A_2_LANE_TYPE_DOUBLE__LANE_CHOICE (4u)
#define LKA_DBC_0_96_NEXT_LANE_A_2_LANE_TYPE_BOTT_S__DOTS_CHOICE (5u)
#define LKA_DBC_0_96_NEXT_LANE_A_2_LANE_TYPE_INVALID_CHOICE (6u)

#define LKA_DBC_0_96_NEXT_LANE_A_2_QUALITY_LOW_QUALITY_0_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_2_QUALITY_LOW_QUALITY_1_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_2_QUALITY_HIGH_QUALITY_2_CHOICE (2u)
#define LKA_DBC_0_96_NEXT_LANE_A_2_QUALITY_HIGH_QUALITY_3_CHOICE (3u)

#define LKA_DBC_0_96_NEXT_LANE_A_2_MODEL_DEGREE_PARABOLIC_MODEL_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_2_MODEL_DEGREE_LINEAR_MODEL_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_2_MODEL_DEGREE_3RD_DEGREE_MODEL_CHOICE (2u)

#define LKA_DBC_0_96_NEXT_LANE_A_1_LANE_TYPE_DASHED_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_1_LANE_TYPE_SOLID_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_1_LANE_TYPE_UNDECIDED_CHOICE (2u)
#define LKA_DBC_0_96_NEXT_LANE_A_1_LANE_TYPE_ROAD__EDGE_CHOICE (3u)
#define LKA_DBC_0_96_NEXT_LANE_A_1_LANE_TYPE_DOUBLE__LANE_CHOICE (4u)
#define LKA_DBC_0_96_NEXT_LANE_A_1_LANE_TYPE_BOTT_S__DOTS_CHOICE (5u)
#define LKA_DBC_0_96_NEXT_LANE_A_1_LANE_TYPE_INVALID_CHOICE (6u)

#define LKA_DBC_0_96_NEXT_LANE_A_1_QUALITY_LOW_QUALITY_0_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_1_QUALITY_LOW_QUALITY_1_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_1_QUALITY_HIGH_QUALITY_2_CHOICE (2u)
#define LKA_DBC_0_96_NEXT_LANE_A_1_QUALITY_HIGH_QUALITY_3_CHOICE (3u)

#define LKA_DBC_0_96_NEXT_LANE_A_1_MODEL_DEGREE_PARABOLIC_MODEL_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_1_MODEL_DEGREE_LINEAR_MODEL_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_1_MODEL_DEGREE_3RD_DEGREE_MODEL_CHOICE (2u)

#define LKA_DBC_0_96_NEXT_LANE_A_LANE_TYPE_DASHED_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_LANE_TYPE_SOLID_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_LANE_TYPE_UNDECIDED_CHOICE (2u)
#define LKA_DBC_0_96_NEXT_LANE_A_LANE_TYPE_ROAD__EDGE_CHOICE (3u)
#define LKA_DBC_0_96_NEXT_LANE_A_LANE_TYPE_DOUBLE__LANE_CHOICE (4u)
#define LKA_DBC_0_96_NEXT_LANE_A_LANE_TYPE_BOTT_S__DOTS_CHOICE (5u)
#define LKA_DBC_0_96_NEXT_LANE_A_LANE_TYPE_INVALID_CHOICE (6u)

#define LKA_DBC_0_96_NEXT_LANE_A_QUALITY_LOW_QUALITY_0_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_QUALITY_LOW_QUALITY_1_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_QUALITY_HIGH_QUALITY_2_CHOICE (2u)
#define LKA_DBC_0_96_NEXT_LANE_A_QUALITY_HIGH_QUALITY_3_CHOICE (3u)

#define LKA_DBC_0_96_NEXT_LANE_A_MODEL_DEGREE_PARABOLIC_MODEL_CHOICE (0u)
#define LKA_DBC_0_96_NEXT_LANE_A_MODEL_DEGREE_LINEAR_MODEL_CHOICE (1u)
#define LKA_DBC_0_96_NEXT_LANE_A_MODEL_DEGREE_3RD_DEGREE_MODEL_CHOICE (2u)

#define LKA_DBC_0_96_LKA_RIGHT_LANE_B_VIEW_RANGE_AVAILABILITY_NOT__VALID_CHOICE (0u)
#define LKA_DBC_0_96_LKA_RIGHT_LANE_B_VIEW_RANGE_AVAILABILITY_VALID_CHOICE (1u)

#define LKA_DBC_0_96_LKA_RIGHT_LANE_A_LANE_TYPE_DASHED_CHOICE (0u)
#define LKA_DBC_0_96_LKA_RIGHT_LANE_A_LANE_TYPE_SOLID_CHOICE (1u)
#define LKA_DBC_0_96_LKA_RIGHT_LANE_A_LANE_TYPE_UNDECIDED_CHOICE (2u)
#define LKA_DBC_0_96_LKA_RIGHT_LANE_A_LANE_TYPE_ROAD__EDGE_CHOICE (3u)
#define LKA_DBC_0_96_LKA_RIGHT_LANE_A_LANE_TYPE_DOUBLE__LANE_CHOICE (4u)
#define LKA_DBC_0_96_LKA_RIGHT_LANE_A_LANE_TYPE_BOTT_S__DOTS_CHOICE (5u)
#define LKA_DBC_0_96_LKA_RIGHT_LANE_A_LANE_TYPE_INVALID_CHOICE (6u)

#define LKA_DBC_0_96_LKA_RIGHT_LANE_A_QUALITY_LOW_QUALITY_0_CHOICE (0u)
#define LKA_DBC_0_96_LKA_RIGHT_LANE_A_QUALITY_LOW_QUALITY_1_CHOICE (1u)
#define LKA_DBC_0_96_LKA_RIGHT_LANE_A_QUALITY_HIGH_QUALITY_2_CHOICE (2u)
#define LKA_DBC_0_96_LKA_RIGHT_LANE_A_QUALITY_HIGH_QUALITY_3_CHOICE (3u)

#define LKA_DBC_0_96_LKA_RIGHT_LANE_A_MODEL_DEGREE_PARABOLIC_MODEL_CHOICE (0u)
#define LKA_DBC_0_96_LKA_RIGHT_LANE_A_MODEL_DEGREE_LINEAR_MODEL_CHOICE (1u)
#define LKA_DBC_0_96_LKA_RIGHT_LANE_A_MODEL_DEGREE_3RD_DEGREE_MODEL_CHOICE (2u)

#define LKA_DBC_0_96_LKA_LEFT_LANE_B_VIEW_RANGE_AVAILABILITY_NOT__VALID_CHOICE (0u)
#define LKA_DBC_0_96_LKA_LEFT_LANE_B_VIEW_RANGE_AVAILABILITY_VALID_CHOICE (1u)

#define LKA_DBC_0_96_LKA_LEFT_LANE_A_LANE_TYPE_DASHED_CHOICE (0u)
#define LKA_DBC_0_96_LKA_LEFT_LANE_A_LANE_TYPE_SOLID_CHOICE (1u)
#define LKA_DBC_0_96_LKA_LEFT_LANE_A_LANE_TYPE_UNDECIDED_CHOICE (2u)
#define LKA_DBC_0_96_LKA_LEFT_LANE_A_LANE_TYPE_ROAD__EDGE_CHOICE (3u)
#define LKA_DBC_0_96_LKA_LEFT_LANE_A_LANE_TYPE_DOUBLE__LANE_CHOICE (4u)
#define LKA_DBC_0_96_LKA_LEFT_LANE_A_LANE_TYPE_BOTT_S__DOTS_CHOICE (5u)
#define LKA_DBC_0_96_LKA_LEFT_LANE_A_LANE_TYPE_INVALID_CHOICE (6u)

#define LKA_DBC_0_96_LKA_LEFT_LANE_A_QUALITY_LOW_QUALITY_0_CHOICE (0u)
#define LKA_DBC_0_96_LKA_LEFT_LANE_A_QUALITY_LOW_QUALITY_1_CHOICE (1u)
#define LKA_DBC_0_96_LKA_LEFT_LANE_A_QUALITY_HIGH_QUALITY_2_CHOICE (2u)
#define LKA_DBC_0_96_LKA_LEFT_LANE_A_QUALITY_HIGH_QUALITY_3_CHOICE (3u)

#define LKA_DBC_0_96_LKA_LEFT_LANE_A_MODEL_DEGREE_PARABOLIC_MODEL_CHOICE (0u)
#define LKA_DBC_0_96_LKA_LEFT_LANE_A_MODEL_DEGREE_LINEAR_MODEL_CHOICE (1u)
#define LKA_DBC_0_96_LKA_LEFT_LANE_A_MODEL_DEGREE_3RD_DEGREE_MODEL_CHOICE (2u)

/**
 * Signals in message Next_Lane_B_8.
 *
 * All signal values are as on the CAN bus.
 */
struct lka_dbc_0_96_next_lane_b_8_t {
    /**
     * Range: 32401.432..33132.568 (-0.357..0.357 radians)
     * Scale: 0.0009765625
     * Offset: -31.9990234375
     */
    uint16_t heading_angle;

    /**
     * Range: 0..32767 (0..127.99609375 meter)
     * Scale: 0.00390625
     * Offset: 0
     */
    uint16_t view_range;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t view_range_availability;
};

/**
 * Signals in message Next_Lane_B_7.
 *
 * All signal values are as on the CAN bus.
 */
struct lka_dbc_0_96_next_lane_b_7_t {
    /**
     * Range: 32401.432..33132.568 (-0.357..0.357 radians)
     * Scale: 0.0009765625
     * Offset: -31.9990234375
     */
    uint16_t heading_angle;

    /**
     * Range: 0..32767 (0..127.99609375 meter)
     * Scale: 0.00390625
     * Offset: 0
     */
    uint16_t view_range;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t view_range_availability;
};

/**
 * Signals in message Next_Lane_B_6.
 *
 * All signal values are as on the CAN bus.
 */
struct lka_dbc_0_96_next_lane_b_6_t {
    /**
     * Range: 32401.432..33132.568 (-0.357..0.357 radians)
     * Scale: 0.0009765625
     * Offset: -31.9990234375
     */
    uint16_t heading_angle;

    /**
     * Range: 0..32767 (0..127.99609375 meter)
     * Scale: 0.00390625
     * Offset: 0
     */
    uint16_t view_range;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t view_range_availability;
};

/**
 * Signals in message Next_Lane_B_5.
 *
 * All signal values are as on the CAN bus.
 */
struct lka_dbc_0_96_next_lane_b_5_t {
    /**
     * Range: 32401.432..33132.568 (-0.357..0.357 radians)
     * Scale: 0.0009765625
     * Offset: -31.9990234375
     */
    uint16_t heading_angle;

    /**
     * Range: 0..32767 (0..127.99609375 meter)
     * Scale: 0.00390625
     * Offset: 0
     */
    uint16_t view_range;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t view_range_availability;
};

/**
 * Signals in message Next_Lane_B_4.
 *
 * All signal values are as on the CAN bus.
 */
struct lka_dbc_0_96_next_lane_b_4_t {
    /**
     * Range: 32401.432..33132.568 (-0.357..0.357 radians)
     * Scale: 0.0009765625
     * Offset: -31.9990234375
     */
    uint16_t heading_angle;

    /**
     * Range: 0..32767 (0..127.99609375 meter)
     * Scale: 0.00390625
     * Offset: 0
     */
    uint16_t view_range;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t view_range_availability;
};

/**
 * Signals in message Next_Lane_B_3.
 *
 * All signal values are as on the CAN bus.
 */
struct lka_dbc_0_96_next_lane_b_3_t {
    /**
     * Range: 32401.432..33132.568 (-0.357..0.357 radians)
     * Scale: 0.0009765625
     * Offset: -31.9990234375
     */
    uint16_t heading_angle;

    /**
     * Range: 0..32767 (0..127.99609375 meter)
     * Scale: 0.00390625
     * Offset: 0
     */
    uint16_t view_range;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t view_range_availability;
};

/**
 * Signals in message Next_Lane_B_2.
 *
 * All signal values are as on the CAN bus.
 */
struct lka_dbc_0_96_next_lane_b_2_t {
    /**
     * Range: 32401.432..33132.568 (-0.357..0.357 radians)
     * Scale: 0.0009765625
     * Offset: -31.9990234375
     */
    uint16_t heading_angle;

    /**
     * Range: 0..32767 (0..127.99609375 meter)
     * Scale: 0.00390625
     * Offset: 0
     */
    uint16_t view_range;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t view_range_availability;
};

/**
 * Signals in message Next_Lane_B_1.
 *
 * All signal values are as on the CAN bus.
 */
struct lka_dbc_0_96_next_lane_b_1_t {
    /**
     * Range: 32401.432..33132.568 (-0.357..0.357 radians)
     * Scale: 0.0009765625
     * Offset: -31.9990234375
     */
    uint16_t heading_angle;

    /**
     * Range: 0..32767 (0..127.99609375 meter)
     * Scale: 0.00390625
     * Offset: 0
     */
    uint16_t view_range;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t view_range_availability;
};

/**
 * Signals in message Next_Lane_B.
 *
 * All signal values are as on the CAN bus.
 */
struct lka_dbc_0_96_next_lane_b_t {
    /**
     * Range: 32401.432..33132.568 (-0.357..0.357 radians)
     * Scale: 0.0009765625
     * Offset: -31.9990234375
     */
    uint16_t heading_angle;

    /**
     * Range: 0..32767 (0..127.99609375 meter)
     * Scale: 0.00390625
     * Offset: 0
     */
    uint16_t view_range;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t view_range_availability;
};

/**
 * Signals in message Next_Lane_A_8.
 *
 * All signal values are as on the CAN bus.
 */
struct lka_dbc_0_96_next_lane_a_8_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t lane_type;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t quality;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t model_degree;

    /**
     * Range: -32768..32512 (-128..127 meter)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t position;

    /**
     * Range: 12287.000000512..53247.000000512 (-0.02..0.02 1/meter)
     * Scale: 9.765625e-07
     * Offset: -0.031999023438
     */
    uint16_t curvature;

    /**
     * Range: 554.7452800744462572787064101..64979.25471941579481178250517 (-0.00012..0.00012 1/meter^2)
     * Scale: 3.7252902985e-09
     * Offset: -0.00012206658721
     */
    uint16_t curvature_derivative;

    /**
     * Range: 0..250 (0..2.5 meter)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t lane_mark_width;
};

/**
 * Signals in message Next_Lane_A_7.
 *
 * All signal values are as on the CAN bus.
 */
struct lka_dbc_0_96_next_lane_a_7_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t lane_type;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t quality;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t model_degree;

    /**
     * Range: -32768..32512 (-128..127 meter)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t position;

    /**
     * Range: 12287.000000512..53247.000000512 (-0.02..0.02 1/meter)
     * Scale: 9.765625e-07
     * Offset: -0.031999023438
     */
    uint16_t curvature;

    /**
     * Range: 554.7452800744462572787064101..64979.25471941579481178250517 (-0.00012..0.00012 1/meter^2)
     * Scale: 3.7252902985e-09
     * Offset: -0.00012206658721
     */
    uint16_t curvature_derivative;

    /**
     * Range: 0..250 (0..2.5 meter)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t lane_mark_width;
};

/**
 * Signals in message Next_Lane_A_6.
 *
 * All signal values are as on the CAN bus.
 */
struct lka_dbc_0_96_next_lane_a_6_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t lane_type;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t quality;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t model_degree;

    /**
     * Range: -32768..32512 (-128..127 meter)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t position;

    /**
     * Range: 12287.000000512..53247.000000512 (-0.02..0.02 1/meter)
     * Scale: 9.765625e-07
     * Offset: -0.031999023438
     */
    uint16_t curvature;

    /**
     * Range: 554.7452800744462572787064101..64979.25471941579481178250517 (-0.00012..0.00012 1/meter^2)
     * Scale: 3.7252902985e-09
     * Offset: -0.00012206658721
     */
    uint16_t curvature_derivative;

    /**
     * Range: 0..250 (0..2.5 meter)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t lane_mark_width;
};

/**
 * Signals in message Next_Lane_A_5.
 *
 * All signal values are as on the CAN bus.
 */
struct lka_dbc_0_96_next_lane_a_5_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t lane_type;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t quality;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t model_degree;

    /**
     * Range: -32768..32512 (-128..127 meter)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t position;

    /**
     * Range: 12287.000000512..53247.000000512 (-0.02..0.02 1/meter)
     * Scale: 9.765625e-07
     * Offset: -0.031999023438
     */
    uint16_t curvature;

    /**
     * Range: 554.7452800744462572787064101..64979.25471941579481178250517 (-0.00012..0.00012 1/meter^2)
     * Scale: 3.7252902985e-09
     * Offset: -0.00012206658721
     */
    uint16_t curvature_derivative;

    /**
     * Range: 0..250 (0..2.5 meter)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t lane_mark_width;
};

/**
 * Signals in message Next_Lane_A_4.
 *
 * All signal values are as on the CAN bus.
 */
struct lka_dbc_0_96_next_lane_a_4_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t lane_type;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t quality;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t model_degree;

    /**
     * Range: -32768..32512 (-128..127 meter)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t position;

    /**
     * Range: 12287.000000512..53247.000000512 (-0.02..0.02 1/meter)
     * Scale: 9.765625e-07
     * Offset: -0.031999023438
     */
    uint16_t curvature;

    /**
     * Range: 554.7452800744462572787064101..64979.25471941579481178250517 (-0.00012..0.00012 1/meter^2)
     * Scale: 3.7252902985e-09
     * Offset: -0.00012206658721
     */
    uint16_t curvature_derivative;

    /**
     * Range: 0..250 (0..2.5 meter)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t lane_mark_width;
};

/**
 * Signals in message Next_Lane_A_3.
 *
 * All signal values are as on the CAN bus.
 */
struct lka_dbc_0_96_next_lane_a_3_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t lane_type;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t quality;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t model_degree;

    /**
     * Range: -32768..32512 (-128..127 meter)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t position;

    /**
     * Range: 12287.000000512..53247.000000512 (-0.02..0.02 1/meter)
     * Scale: 9.765625e-07
     * Offset: -0.031999023438
     */
    uint16_t curvature;

    /**
     * Range: 554.7452800744462572787064101..64979.25471941579481178250517 (-0.00012..0.00012 1/meter^2)
     * Scale: 3.7252902985e-09
     * Offset: -0.00012206658721
     */
    uint16_t curvature_derivative;

    /**
     * Range: 0..250 (0..2.5 meter)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t lane_mark_width;
};

/**
 * Signals in message Next_Lane_A_2.
 *
 * All signal values are as on the CAN bus.
 */
struct lka_dbc_0_96_next_lane_a_2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t lane_type;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t quality;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t model_degree;

    /**
     * Range: -32768..32512 (-128..127 meter)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t position;

    /**
     * Range: 12287.000000512..53247.000000512 (-0.02..0.02 1/meter)
     * Scale: 9.765625e-07
     * Offset: -0.031999023438
     */
    uint16_t curvature;

    /**
     * Range: 554.7452800744462572787064101..64979.25471941579481178250517 (-0.00012..0.00012 1/meter^2)
     * Scale: 3.7252902985e-09
     * Offset: -0.00012206658721
     */
    uint16_t curvature_derivative;

    /**
     * Range: 0..250 (0..2.5 meter)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t lane_mark_width;
};

/**
 * Signals in message Next_Lane_A_1.
 *
 * All signal values are as on the CAN bus.
 */
struct lka_dbc_0_96_next_lane_a_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t lane_type;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t quality;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t model_degree;

    /**
     * Range: -32768..32512 (-128..127 meter)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t position;

    /**
     * Range: 12287.000000512..53247.000000512 (-0.02..0.02 1/meter)
     * Scale: 9.765625e-07
     * Offset: -0.031999023438
     */
    uint16_t curvature;

    /**
     * Range: 554.7452800744462572787064101..64979.25471941579481178250517 (-0.00012..0.00012 1/meter^2)
     * Scale: 3.7252902985e-09
     * Offset: -0.00012206658721
     */
    uint16_t curvature_derivative;

    /**
     * Range: 0..250 (0..2.5 meter)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t lane_mark_width;
};

/**
 * Signals in message Next_Lane_A.
 *
 * All signal values are as on the CAN bus.
 */
struct lka_dbc_0_96_next_lane_a_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t lane_type;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t quality;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t model_degree;

    /**
     * Range: -32768..32512 (-128..127 meter)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t position;

    /**
     * Range: 12287.000000512..53247.000000512 (-0.02..0.02 1/meter)
     * Scale: 9.765625e-07
     * Offset: -0.031999023438
     */
    uint16_t curvature;

    /**
     * Range: 554.7452800744462572787064101..64979.25471941579481178250517 (-0.00012..0.00012 1/meter^2)
     * Scale: 3.7252902985e-09
     * Offset: -0.00012206658721
     */
    uint16_t curvature_derivative;

    /**
     * Range: 0..250 (0..2.5 meter)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t lane_mark_width;
};

/**
 * Signals in message Num_Of_Next_Lane_Marks_Reported.
 *
 * All signal values are as on the CAN bus.
 */
struct lka_dbc_0_96_num_of_next_lane_marks_reported_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t num_of_next_lane_mark_reported;
};

/**
 * Signals in message Reference_Points.
 *
 * All signal values are as on the CAN bus.
 */
struct lka_dbc_0_96_reference_points_t {
    /**
     * Range: 0..65535 (-127.99609375..128 meters)
     * Scale: 0.00390625
     * Offset: -127.99609375
     */
    uint16_t ref_point_1_position;

    /**
     * Range: 0..32767 (0..127.99609375 meters)
     * Scale: 0.00390625
     * Offset: 0
     */
    uint16_t ref_point_1_distance;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ref_point_1_validity;

    /**
     * Range: 0..65535 (-127.99609375..128 meters)
     * Scale: 0.00390625
     * Offset: -127.99609375
     */
    uint16_t ref_point_2_position;

    /**
     * Range: 0..32767 (0..127.99609375 meters)
     * Scale: 0.00390625
     * Offset: 0
     */
    uint16_t ref_point_2_distance;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ref_point_2_validity;
};

/**
 * Signals in message LKA_Right_Lane_B.
 *
 * All signal values are as on the CAN bus.
 */
struct lka_dbc_0_96_lka_right_lane_b_t {
    /**
     * Range: 32401.432..33132.568 (-0.357..0.357 radians)
     * Scale: 0.0009765625
     * Offset: -31.9990234375
     */
    uint16_t heading_angle;

    /**
     * Range: 0..32767 (0..127.99609375 meter)
     * Scale: 0.00390625
     * Offset: 0
     */
    uint16_t view_range;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t view_range_availability;
};

/**
 * Signals in message LKA_Right_Lane_A.
 *
 * All signal values are as on the CAN bus.
 */
struct lka_dbc_0_96_lka_right_lane_a_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t lane_type;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t quality;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t model_degree;

    /**
     * Range: -32768..32512 (-128..127 meter)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t position;

    /**
     * Range: 12287.000000512..53247.000000512 (-0.02..0.02 1/meter)
     * Scale: 9.765625e-07
     * Offset: -0.031999023438
     */
    uint16_t curvature;

    /**
     * Range: 554.7452800744462572787064101..64979.25471941579481178250517 (-0.00012..0.00012 1/meter^2)
     * Scale: 3.7252902985e-09
     * Offset: -0.00012206658721
     */
    uint16_t curvature_derivative;

    /**
     * Range: 0..255 (0..2.55 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t width_right_marking;
};

/**
 * Signals in message LKA_Left_Lane_B.
 *
 * All signal values are as on the CAN bus.
 */
struct lka_dbc_0_96_lka_left_lane_b_t {
    /**
     * Range: 32401.432..33132.568 (-0.357..0.357 radians)
     * Scale: 0.0009765625
     * Offset: -31.9990234375
     */
    uint16_t heading_angle;

    /**
     * Range: 0..32767 (0..127.99609375 meter)
     * Scale: 0.00390625
     * Offset: 0
     */
    uint16_t view_range;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t view_range_availability;
};

/**
 * Signals in message LKA_Left_Lane_A.
 *
 * All signal values are as on the CAN bus.
 */
struct lka_dbc_0_96_lka_left_lane_a_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t lane_type;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t quality;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t model_degree;

    /**
     * Range: -32768..32512 (-128..127 meter)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t position;

    /**
     * Range: 12287.000000512..53247.000000512 (-0.02..0.02 1/meter)
     * Scale: 9.765625e-07
     * Offset: -0.031999023438
     */
    uint16_t curvature;

    /**
     * Range: 554.7452800744462572787064101..64979.25471941579481178250517 (-0.00012..0.00012 1/meter^2)
     * Scale: 3.7252902985e-09
     * Offset: -0.00012206658721
     */
    uint16_t curvature_derivative;

    /**
     * Range: 0..250 (0..2.5 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t width_left_marking;
};

/**
 * Pack message Next_Lane_B_8.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int lka_dbc_0_96_next_lane_b_8_pack(
    uint8_t *dst_p,
    const struct lka_dbc_0_96_next_lane_b_8_t *src_p,
    size_t size);

/**
 * Unpack message Next_Lane_B_8.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int lka_dbc_0_96_next_lane_b_8_unpack(
    struct lka_dbc_0_96_next_lane_b_8_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_b_8_heading_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_8_heading_angle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_8_heading_angle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_b_8_view_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_8_view_range_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_8_view_range_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_b_8_view_range_availability_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_8_view_range_availability_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_8_view_range_availability_is_in_range(uint8_t value);

/**
 * Pack message Next_Lane_B_7.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int lka_dbc_0_96_next_lane_b_7_pack(
    uint8_t *dst_p,
    const struct lka_dbc_0_96_next_lane_b_7_t *src_p,
    size_t size);

/**
 * Unpack message Next_Lane_B_7.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int lka_dbc_0_96_next_lane_b_7_unpack(
    struct lka_dbc_0_96_next_lane_b_7_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_b_7_heading_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_7_heading_angle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_7_heading_angle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_b_7_view_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_7_view_range_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_7_view_range_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_b_7_view_range_availability_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_7_view_range_availability_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_7_view_range_availability_is_in_range(uint8_t value);

/**
 * Pack message Next_Lane_B_6.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int lka_dbc_0_96_next_lane_b_6_pack(
    uint8_t *dst_p,
    const struct lka_dbc_0_96_next_lane_b_6_t *src_p,
    size_t size);

/**
 * Unpack message Next_Lane_B_6.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int lka_dbc_0_96_next_lane_b_6_unpack(
    struct lka_dbc_0_96_next_lane_b_6_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_b_6_heading_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_6_heading_angle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_6_heading_angle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_b_6_view_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_6_view_range_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_6_view_range_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_b_6_view_range_availability_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_6_view_range_availability_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_6_view_range_availability_is_in_range(uint8_t value);

/**
 * Pack message Next_Lane_B_5.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int lka_dbc_0_96_next_lane_b_5_pack(
    uint8_t *dst_p,
    const struct lka_dbc_0_96_next_lane_b_5_t *src_p,
    size_t size);

/**
 * Unpack message Next_Lane_B_5.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int lka_dbc_0_96_next_lane_b_5_unpack(
    struct lka_dbc_0_96_next_lane_b_5_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_b_5_heading_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_5_heading_angle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_5_heading_angle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_b_5_view_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_5_view_range_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_5_view_range_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_b_5_view_range_availability_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_5_view_range_availability_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_5_view_range_availability_is_in_range(uint8_t value);

/**
 * Pack message Next_Lane_B_4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int lka_dbc_0_96_next_lane_b_4_pack(
    uint8_t *dst_p,
    const struct lka_dbc_0_96_next_lane_b_4_t *src_p,
    size_t size);

/**
 * Unpack message Next_Lane_B_4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int lka_dbc_0_96_next_lane_b_4_unpack(
    struct lka_dbc_0_96_next_lane_b_4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_b_4_heading_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_4_heading_angle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_4_heading_angle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_b_4_view_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_4_view_range_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_4_view_range_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_b_4_view_range_availability_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_4_view_range_availability_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_4_view_range_availability_is_in_range(uint8_t value);

/**
 * Pack message Next_Lane_B_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int lka_dbc_0_96_next_lane_b_3_pack(
    uint8_t *dst_p,
    const struct lka_dbc_0_96_next_lane_b_3_t *src_p,
    size_t size);

/**
 * Unpack message Next_Lane_B_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int lka_dbc_0_96_next_lane_b_3_unpack(
    struct lka_dbc_0_96_next_lane_b_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_b_3_heading_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_3_heading_angle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_3_heading_angle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_b_3_view_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_3_view_range_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_3_view_range_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_b_3_view_range_availability_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_3_view_range_availability_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_3_view_range_availability_is_in_range(uint8_t value);

/**
 * Pack message Next_Lane_B_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int lka_dbc_0_96_next_lane_b_2_pack(
    uint8_t *dst_p,
    const struct lka_dbc_0_96_next_lane_b_2_t *src_p,
    size_t size);

/**
 * Unpack message Next_Lane_B_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int lka_dbc_0_96_next_lane_b_2_unpack(
    struct lka_dbc_0_96_next_lane_b_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_b_2_heading_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_2_heading_angle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_2_heading_angle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_b_2_view_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_2_view_range_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_2_view_range_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_b_2_view_range_availability_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_2_view_range_availability_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_2_view_range_availability_is_in_range(uint8_t value);

/**
 * Pack message Next_Lane_B_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int lka_dbc_0_96_next_lane_b_1_pack(
    uint8_t *dst_p,
    const struct lka_dbc_0_96_next_lane_b_1_t *src_p,
    size_t size);

/**
 * Unpack message Next_Lane_B_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int lka_dbc_0_96_next_lane_b_1_unpack(
    struct lka_dbc_0_96_next_lane_b_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_b_1_heading_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_1_heading_angle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_1_heading_angle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_b_1_view_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_1_view_range_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_1_view_range_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_b_1_view_range_availability_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_1_view_range_availability_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_1_view_range_availability_is_in_range(uint8_t value);

/**
 * Pack message Next_Lane_B.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int lka_dbc_0_96_next_lane_b_pack(
    uint8_t *dst_p,
    const struct lka_dbc_0_96_next_lane_b_t *src_p,
    size_t size);

/**
 * Unpack message Next_Lane_B.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int lka_dbc_0_96_next_lane_b_unpack(
    struct lka_dbc_0_96_next_lane_b_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_b_heading_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_heading_angle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_heading_angle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_b_view_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_view_range_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_view_range_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_b_view_range_availability_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_b_view_range_availability_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_b_view_range_availability_is_in_range(uint8_t value);

/**
 * Pack message Next_Lane_A_8.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int lka_dbc_0_96_next_lane_a_8_pack(
    uint8_t *dst_p,
    const struct lka_dbc_0_96_next_lane_a_8_t *src_p,
    size_t size);

/**
 * Unpack message Next_Lane_A_8.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int lka_dbc_0_96_next_lane_a_8_unpack(
    struct lka_dbc_0_96_next_lane_a_8_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_8_lane_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_8_lane_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_8_lane_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_8_quality_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_8_quality_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_8_quality_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_8_model_degree_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_8_model_degree_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_8_model_degree_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t lka_dbc_0_96_next_lane_a_8_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_8_position_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_8_position_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_a_8_curvature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_8_curvature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_8_curvature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_a_8_curvature_derivative_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_8_curvature_derivative_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_8_curvature_derivative_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_8_lane_mark_width_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_8_lane_mark_width_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_8_lane_mark_width_is_in_range(uint8_t value);

/**
 * Pack message Next_Lane_A_7.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int lka_dbc_0_96_next_lane_a_7_pack(
    uint8_t *dst_p,
    const struct lka_dbc_0_96_next_lane_a_7_t *src_p,
    size_t size);

/**
 * Unpack message Next_Lane_A_7.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int lka_dbc_0_96_next_lane_a_7_unpack(
    struct lka_dbc_0_96_next_lane_a_7_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_7_lane_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_7_lane_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_7_lane_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_7_quality_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_7_quality_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_7_quality_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_7_model_degree_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_7_model_degree_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_7_model_degree_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t lka_dbc_0_96_next_lane_a_7_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_7_position_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_7_position_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_a_7_curvature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_7_curvature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_7_curvature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_a_7_curvature_derivative_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_7_curvature_derivative_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_7_curvature_derivative_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_7_lane_mark_width_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_7_lane_mark_width_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_7_lane_mark_width_is_in_range(uint8_t value);

/**
 * Pack message Next_Lane_A_6.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int lka_dbc_0_96_next_lane_a_6_pack(
    uint8_t *dst_p,
    const struct lka_dbc_0_96_next_lane_a_6_t *src_p,
    size_t size);

/**
 * Unpack message Next_Lane_A_6.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int lka_dbc_0_96_next_lane_a_6_unpack(
    struct lka_dbc_0_96_next_lane_a_6_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_6_lane_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_6_lane_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_6_lane_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_6_quality_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_6_quality_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_6_quality_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_6_model_degree_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_6_model_degree_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_6_model_degree_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t lka_dbc_0_96_next_lane_a_6_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_6_position_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_6_position_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_a_6_curvature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_6_curvature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_6_curvature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_a_6_curvature_derivative_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_6_curvature_derivative_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_6_curvature_derivative_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_6_lane_mark_width_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_6_lane_mark_width_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_6_lane_mark_width_is_in_range(uint8_t value);

/**
 * Pack message Next_Lane_A_5.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int lka_dbc_0_96_next_lane_a_5_pack(
    uint8_t *dst_p,
    const struct lka_dbc_0_96_next_lane_a_5_t *src_p,
    size_t size);

/**
 * Unpack message Next_Lane_A_5.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int lka_dbc_0_96_next_lane_a_5_unpack(
    struct lka_dbc_0_96_next_lane_a_5_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_5_lane_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_5_lane_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_5_lane_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_5_quality_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_5_quality_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_5_quality_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_5_model_degree_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_5_model_degree_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_5_model_degree_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t lka_dbc_0_96_next_lane_a_5_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_5_position_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_5_position_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_a_5_curvature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_5_curvature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_5_curvature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_a_5_curvature_derivative_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_5_curvature_derivative_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_5_curvature_derivative_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_5_lane_mark_width_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_5_lane_mark_width_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_5_lane_mark_width_is_in_range(uint8_t value);

/**
 * Pack message Next_Lane_A_4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int lka_dbc_0_96_next_lane_a_4_pack(
    uint8_t *dst_p,
    const struct lka_dbc_0_96_next_lane_a_4_t *src_p,
    size_t size);

/**
 * Unpack message Next_Lane_A_4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int lka_dbc_0_96_next_lane_a_4_unpack(
    struct lka_dbc_0_96_next_lane_a_4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_4_lane_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_4_lane_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_4_lane_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_4_quality_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_4_quality_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_4_quality_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_4_model_degree_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_4_model_degree_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_4_model_degree_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t lka_dbc_0_96_next_lane_a_4_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_4_position_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_4_position_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_a_4_curvature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_4_curvature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_4_curvature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_a_4_curvature_derivative_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_4_curvature_derivative_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_4_curvature_derivative_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_4_lane_mark_width_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_4_lane_mark_width_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_4_lane_mark_width_is_in_range(uint8_t value);

/**
 * Pack message Next_Lane_A_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int lka_dbc_0_96_next_lane_a_3_pack(
    uint8_t *dst_p,
    const struct lka_dbc_0_96_next_lane_a_3_t *src_p,
    size_t size);

/**
 * Unpack message Next_Lane_A_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int lka_dbc_0_96_next_lane_a_3_unpack(
    struct lka_dbc_0_96_next_lane_a_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_3_lane_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_3_lane_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_3_lane_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_3_quality_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_3_quality_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_3_quality_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_3_model_degree_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_3_model_degree_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_3_model_degree_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t lka_dbc_0_96_next_lane_a_3_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_3_position_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_3_position_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_a_3_curvature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_3_curvature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_3_curvature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_a_3_curvature_derivative_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_3_curvature_derivative_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_3_curvature_derivative_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_3_lane_mark_width_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_3_lane_mark_width_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_3_lane_mark_width_is_in_range(uint8_t value);

/**
 * Pack message Next_Lane_A_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int lka_dbc_0_96_next_lane_a_2_pack(
    uint8_t *dst_p,
    const struct lka_dbc_0_96_next_lane_a_2_t *src_p,
    size_t size);

/**
 * Unpack message Next_Lane_A_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int lka_dbc_0_96_next_lane_a_2_unpack(
    struct lka_dbc_0_96_next_lane_a_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_2_lane_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_2_lane_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_2_lane_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_2_quality_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_2_quality_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_2_quality_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_2_model_degree_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_2_model_degree_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_2_model_degree_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t lka_dbc_0_96_next_lane_a_2_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_2_position_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_2_position_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_a_2_curvature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_2_curvature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_2_curvature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_a_2_curvature_derivative_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_2_curvature_derivative_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_2_curvature_derivative_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_2_lane_mark_width_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_2_lane_mark_width_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_2_lane_mark_width_is_in_range(uint8_t value);

/**
 * Pack message Next_Lane_A_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int lka_dbc_0_96_next_lane_a_1_pack(
    uint8_t *dst_p,
    const struct lka_dbc_0_96_next_lane_a_1_t *src_p,
    size_t size);

/**
 * Unpack message Next_Lane_A_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int lka_dbc_0_96_next_lane_a_1_unpack(
    struct lka_dbc_0_96_next_lane_a_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_1_lane_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_1_lane_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_1_lane_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_1_quality_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_1_quality_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_1_quality_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_1_model_degree_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_1_model_degree_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_1_model_degree_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t lka_dbc_0_96_next_lane_a_1_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_1_position_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_1_position_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_a_1_curvature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_1_curvature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_1_curvature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_a_1_curvature_derivative_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_1_curvature_derivative_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_1_curvature_derivative_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_1_lane_mark_width_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_1_lane_mark_width_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_1_lane_mark_width_is_in_range(uint8_t value);

/**
 * Pack message Next_Lane_A.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int lka_dbc_0_96_next_lane_a_pack(
    uint8_t *dst_p,
    const struct lka_dbc_0_96_next_lane_a_t *src_p,
    size_t size);

/**
 * Unpack message Next_Lane_A.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int lka_dbc_0_96_next_lane_a_unpack(
    struct lka_dbc_0_96_next_lane_a_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_lane_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_lane_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_lane_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_quality_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_quality_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_quality_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_model_degree_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_model_degree_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_model_degree_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t lka_dbc_0_96_next_lane_a_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_position_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_position_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_a_curvature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_curvature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_curvature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_next_lane_a_curvature_derivative_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_curvature_derivative_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_curvature_derivative_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_next_lane_a_lane_mark_width_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_next_lane_a_lane_mark_width_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_next_lane_a_lane_mark_width_is_in_range(uint8_t value);

/**
 * Pack message Num_Of_Next_Lane_Marks_Reported.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int lka_dbc_0_96_num_of_next_lane_marks_reported_pack(
    uint8_t *dst_p,
    const struct lka_dbc_0_96_num_of_next_lane_marks_reported_t *src_p,
    size_t size);

/**
 * Unpack message Num_Of_Next_Lane_Marks_Reported.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int lka_dbc_0_96_num_of_next_lane_marks_reported_unpack(
    struct lka_dbc_0_96_num_of_next_lane_marks_reported_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_num_of_next_lane_marks_reported_num_of_next_lane_mark_reported_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_num_of_next_lane_marks_reported_num_of_next_lane_mark_reported_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_num_of_next_lane_marks_reported_num_of_next_lane_mark_reported_is_in_range(uint8_t value);

/**
 * Pack message Reference_Points.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int lka_dbc_0_96_reference_points_pack(
    uint8_t *dst_p,
    const struct lka_dbc_0_96_reference_points_t *src_p,
    size_t size);

/**
 * Unpack message Reference_Points.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int lka_dbc_0_96_reference_points_unpack(
    struct lka_dbc_0_96_reference_points_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_reference_points_ref_point_1_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_reference_points_ref_point_1_position_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_reference_points_ref_point_1_position_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_reference_points_ref_point_1_distance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_reference_points_ref_point_1_distance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_reference_points_ref_point_1_distance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_reference_points_ref_point_1_validity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_reference_points_ref_point_1_validity_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_reference_points_ref_point_1_validity_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_reference_points_ref_point_2_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_reference_points_ref_point_2_position_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_reference_points_ref_point_2_position_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_reference_points_ref_point_2_distance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_reference_points_ref_point_2_distance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_reference_points_ref_point_2_distance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_reference_points_ref_point_2_validity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_reference_points_ref_point_2_validity_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_reference_points_ref_point_2_validity_is_in_range(uint8_t value);

/**
 * Pack message LKA_Right_Lane_B.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int lka_dbc_0_96_lka_right_lane_b_pack(
    uint8_t *dst_p,
    const struct lka_dbc_0_96_lka_right_lane_b_t *src_p,
    size_t size);

/**
 * Unpack message LKA_Right_Lane_B.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int lka_dbc_0_96_lka_right_lane_b_unpack(
    struct lka_dbc_0_96_lka_right_lane_b_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_lka_right_lane_b_heading_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_lka_right_lane_b_heading_angle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_lka_right_lane_b_heading_angle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_lka_right_lane_b_view_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_lka_right_lane_b_view_range_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_lka_right_lane_b_view_range_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_lka_right_lane_b_view_range_availability_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_lka_right_lane_b_view_range_availability_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_lka_right_lane_b_view_range_availability_is_in_range(uint8_t value);

/**
 * Pack message LKA_Right_Lane_A.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int lka_dbc_0_96_lka_right_lane_a_pack(
    uint8_t *dst_p,
    const struct lka_dbc_0_96_lka_right_lane_a_t *src_p,
    size_t size);

/**
 * Unpack message LKA_Right_Lane_A.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int lka_dbc_0_96_lka_right_lane_a_unpack(
    struct lka_dbc_0_96_lka_right_lane_a_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_lka_right_lane_a_lane_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_lka_right_lane_a_lane_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_lka_right_lane_a_lane_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_lka_right_lane_a_quality_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_lka_right_lane_a_quality_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_lka_right_lane_a_quality_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_lka_right_lane_a_model_degree_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_lka_right_lane_a_model_degree_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_lka_right_lane_a_model_degree_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t lka_dbc_0_96_lka_right_lane_a_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_lka_right_lane_a_position_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_lka_right_lane_a_position_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_lka_right_lane_a_curvature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_lka_right_lane_a_curvature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_lka_right_lane_a_curvature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_lka_right_lane_a_curvature_derivative_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_lka_right_lane_a_curvature_derivative_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_lka_right_lane_a_curvature_derivative_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_lka_right_lane_a_width_right_marking_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_lka_right_lane_a_width_right_marking_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_lka_right_lane_a_width_right_marking_is_in_range(uint8_t value);

/**
 * Pack message LKA_Left_Lane_B.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int lka_dbc_0_96_lka_left_lane_b_pack(
    uint8_t *dst_p,
    const struct lka_dbc_0_96_lka_left_lane_b_t *src_p,
    size_t size);

/**
 * Unpack message LKA_Left_Lane_B.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int lka_dbc_0_96_lka_left_lane_b_unpack(
    struct lka_dbc_0_96_lka_left_lane_b_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_lka_left_lane_b_heading_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_lka_left_lane_b_heading_angle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_lka_left_lane_b_heading_angle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_lka_left_lane_b_view_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_lka_left_lane_b_view_range_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_lka_left_lane_b_view_range_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_lka_left_lane_b_view_range_availability_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_lka_left_lane_b_view_range_availability_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_lka_left_lane_b_view_range_availability_is_in_range(uint8_t value);

/**
 * Pack message LKA_Left_Lane_A.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int lka_dbc_0_96_lka_left_lane_a_pack(
    uint8_t *dst_p,
    const struct lka_dbc_0_96_lka_left_lane_a_t *src_p,
    size_t size);

/**
 * Unpack message LKA_Left_Lane_A.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int lka_dbc_0_96_lka_left_lane_a_unpack(
    struct lka_dbc_0_96_lka_left_lane_a_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_lka_left_lane_a_lane_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_lka_left_lane_a_lane_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_lka_left_lane_a_lane_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_lka_left_lane_a_quality_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_lka_left_lane_a_quality_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_lka_left_lane_a_quality_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_lka_left_lane_a_model_degree_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_lka_left_lane_a_model_degree_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_lka_left_lane_a_model_degree_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t lka_dbc_0_96_lka_left_lane_a_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_lka_left_lane_a_position_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_lka_left_lane_a_position_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_lka_left_lane_a_curvature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_lka_left_lane_a_curvature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_lka_left_lane_a_curvature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t lka_dbc_0_96_lka_left_lane_a_curvature_derivative_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_lka_left_lane_a_curvature_derivative_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_lka_left_lane_a_curvature_derivative_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t lka_dbc_0_96_lka_left_lane_a_width_left_marking_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double lka_dbc_0_96_lka_left_lane_a_width_left_marking_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool lka_dbc_0_96_lka_left_lane_a_width_left_marking_is_in_range(uint8_t value);


#ifdef __cplusplus
}
#endif

#endif
