/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 35.1.0 Thu Jul 23 11:33:28 2020.
 */

#ifndef EXT_LOG_DATA_H
#define EXT_LOG_DATA_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define EXT_LOG_DATA_LKA_RIGHT_LANE_B_FRAME_ID (0x769u)
#define EXT_LOG_DATA_LKA_LEFT_LANE_B_FRAME_ID (0x767u)
#define EXT_LOG_DATA_LKA_RIGHT_LANE_A_FRAME_ID (0x768u)
#define EXT_LOG_DATA_LKA_LEFT_LANE_A_FRAME_ID (0x766u)
#define EXT_LOG_DATA_LANE_DETAILS_FRAME_ID (0x737u)
#define EXT_LOG_DATA_OBSTACLE_DATA_C_FRAME_ID (0x73bu)
#define EXT_LOG_DATA_OBSTACLE_DATA_B_FRAME_ID (0x73au)
#define EXT_LOG_DATA_OBSTACLE_DATA_A_FRAME_ID (0x739u)

/* Frame lengths in bytes. */
#define EXT_LOG_DATA_LKA_RIGHT_LANE_B_LENGTH (8u)
#define EXT_LOG_DATA_LKA_LEFT_LANE_B_LENGTH (8u)
#define EXT_LOG_DATA_LKA_RIGHT_LANE_A_LENGTH (8u)
#define EXT_LOG_DATA_LKA_LEFT_LANE_A_LENGTH (8u)
#define EXT_LOG_DATA_LANE_DETAILS_LENGTH (8u)
#define EXT_LOG_DATA_OBSTACLE_DATA_C_LENGTH (8u)
#define EXT_LOG_DATA_OBSTACLE_DATA_B_LENGTH (8u)
#define EXT_LOG_DATA_OBSTACLE_DATA_A_LENGTH (8u)

/* Extended or standard frame types. */
#define EXT_LOG_DATA_LKA_RIGHT_LANE_B_IS_EXTENDED (0)
#define EXT_LOG_DATA_LKA_LEFT_LANE_B_IS_EXTENDED (0)
#define EXT_LOG_DATA_LKA_RIGHT_LANE_A_IS_EXTENDED (0)
#define EXT_LOG_DATA_LKA_LEFT_LANE_A_IS_EXTENDED (0)
#define EXT_LOG_DATA_LANE_DETAILS_IS_EXTENDED (0)
#define EXT_LOG_DATA_OBSTACLE_DATA_C_IS_EXTENDED (0)
#define EXT_LOG_DATA_OBSTACLE_DATA_B_IS_EXTENDED (0)
#define EXT_LOG_DATA_OBSTACLE_DATA_A_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */
#define EXT_LOG_DATA_LANE_DETAILS_LEFT_GUARD_RAIL_NO_GUARD_RAIL_DETECTED_CHOICE (0u)
#define EXT_LOG_DATA_LANE_DETAILS_LEFT_GUARD_RAIL_GUARD_RAIL_DETECTED_CHOICE (1u)

#define EXT_LOG_DATA_LANE_DETAILS_RIGHT_GUARD_RAIL_NO_GUARD_RAIL_DETECTED_CHOICE (0u)
#define EXT_LOG_DATA_LANE_DETAILS_RIGHT_GUARD_RAIL_GUARD_RAIL_DETECTED_CHOICE (1u)

#define EXT_LOG_DATA_OBSTACLE_DATA_C_OBSTACLE_REPLACED_NOT_REPLACED_IN_THIS_FRAME_CHOICE (0u)
#define EXT_LOG_DATA_OBSTACLE_DATA_C_OBSTACLE_REPLACED_REPLACED_IN_THIS_FRAME_CHOICE (1u)

#define EXT_LOG_DATA_OBSTACLE_DATA_B_OBSTACLE_LANE_NOT_ASSIGNED_CHOICE (0u)
#define EXT_LOG_DATA_OBSTACLE_DATA_B_OBSTACLE_LANE_EGO_LANE_CHOICE (1u)
#define EXT_LOG_DATA_OBSTACLE_DATA_B_OBSTACLE_LANE_NEXT_LANE__LEFT_OR_RIGHT__CHOICE (2u)
#define EXT_LOG_DATA_OBSTACLE_DATA_B_OBSTACLE_LANE_INVALID_CHOICE (3u)

#define EXT_LOG_DATA_OBSTACLE_DATA_B_CIPV_FLAG_NOT_CIPV_CHOICE (0u)
#define EXT_LOG_DATA_OBSTACLE_DATA_B_CIPV_FLAG_CIPV_CHOICE (1u)

#define EXT_LOG_DATA_OBSTACLE_DATA_A_BLINKER_INFO_UNAVAILABLE_CHOICE (0u)
#define EXT_LOG_DATA_OBSTACLE_DATA_A_BLINKER_INFO_OFF_CHOICE (1u)
#define EXT_LOG_DATA_OBSTACLE_DATA_A_BLINKER_INFO_LEFT_CHOICE (2u)
#define EXT_LOG_DATA_OBSTACLE_DATA_A_BLINKER_INFO_RIGHT_CHOICE (3u)
#define EXT_LOG_DATA_OBSTACLE_DATA_A_BLINKER_INFO_BOTH_CHOICE (4u)

#define EXT_LOG_DATA_OBSTACLE_DATA_A_CUT_IN_AND_OUT_UNDEFINED_CHOICE (0u)
#define EXT_LOG_DATA_OBSTACLE_DATA_A_CUT_IN_AND_OUT_IN_HOST_LANE_CHOICE (1u)
#define EXT_LOG_DATA_OBSTACLE_DATA_A_CUT_IN_AND_OUT_OUT_HOST_LANE_CHOICE (2u)
#define EXT_LOG_DATA_OBSTACLE_DATA_A_CUT_IN_AND_OUT_CUT_IN_CHOICE (3u)
#define EXT_LOG_DATA_OBSTACLE_DATA_A_CUT_IN_AND_OUT_CUT_OUT_CHOICE (4u)

#define EXT_LOG_DATA_OBSTACLE_DATA_A_OBSTACLE_TYPE_VEHICLE_CHOICE (0u)
#define EXT_LOG_DATA_OBSTACLE_DATA_A_OBSTACLE_TYPE_TRUCK_CHOICE (1u)
#define EXT_LOG_DATA_OBSTACLE_DATA_A_OBSTACLE_TYPE_BIKE_CHOICE (2u)
#define EXT_LOG_DATA_OBSTACLE_DATA_A_OBSTACLE_TYPE_PEDESTRIAN_CHOICE (3u)
#define EXT_LOG_DATA_OBSTACLE_DATA_A_OBSTACLE_TYPE_BICYCLE_CHOICE (4u)

#define EXT_LOG_DATA_OBSTACLE_DATA_A_OBSTACLE_STATUS_NOT_DEFINED_CHOICE (0u)
#define EXT_LOG_DATA_OBSTACLE_DATA_A_OBSTACLE_STATUS_STANDING_NEVER_MOVED_BCK_LIGHTS_ON_CHOICE (1u)
#define EXT_LOG_DATA_OBSTACLE_DATA_A_OBSTACLE_STATUS_STOPPED__MOVABLE__CHOICE (2u)
#define EXT_LOG_DATA_OBSTACLE_DATA_A_OBSTACLE_STATUS_MOVING_CHOICE (3u)
#define EXT_LOG_DATA_OBSTACLE_DATA_A_OBSTACLE_STATUS_ONCOMING_CHOICE (4u)
#define EXT_LOG_DATA_OBSTACLE_DATA_A_OBSTACLE_STATUS_PARKED_NEVER_MOVED___BCK_LIGHTS_OFF_CHOICE (5u)
#define EXT_LOG_DATA_OBSTACLE_DATA_A_OBSTACLE_STATUS_UNUSED_CHOICE (6u)

#define EXT_LOG_DATA_OBSTACLE_DATA_A_OBSTACLE_BRAKE_LIGHTS_OBJECT_S_BRAKE_LIGHTS_ARE_OFF_CHOICE (0u)
#define EXT_LOG_DATA_OBSTACLE_DATA_A_OBSTACLE_BRAKE_LIGHTS_OBJECT_S_BRAKE_LIGHTS_ARE_ON_CHOICE (1u)

#define EXT_LOG_DATA_OBSTACLE_DATA_A_OBSTACLE_VALID_NEW_VALID__DETECTED_THIS_FRAME__CHOICE (1u)
#define EXT_LOG_DATA_OBSTACLE_DATA_A_OBSTACLE_VALID_OLDER_VALID_CHOICE (2u)

/**
 * Signals in message LKA_Right_Lane_B.
 *
 * All signal values are as on the CAN bus.
 */
struct ext_log_data_lka_right_lane_b_t {
    /**
     * Range: 32401.432..33132.568 (-0.357..0.357 radians)
     * Scale: 0.0009765625
     * Offset: -31.9990234375
     */
    uint16_t heading_angle;

    /**
     * Range: 0..32767 (0..127.99609375 meters)
     * Scale: 0.00390625
     * Offset: 0
     */
    uint16_t view_range;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t view_range_availability;
};

/**
 * Signals in message LKA_Left_Lane_B.
 *
 * All signal values are as on the CAN bus.
 */
struct ext_log_data_lka_left_lane_b_t {
    /**
     * Range: 32401.432..33132.568 (-0.357..0.357 radians)
     * Scale: 0.0009765625
     * Offset: -31.9990234375
     */
    uint16_t heading_angle;

    /**
     * Range: 0..32767 (0..127.99609375 meters)
     * Scale: 0.00390625
     * Offset: 0
     */
    uint16_t view_range;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t view_range_availability;
};

/**
 * Signals in message LKA_Right_Lane_A.
 *
 * All signal values are as on the CAN bus.
 */
struct ext_log_data_lka_right_lane_a_t {
    /**
     * Range: 0..6 (0..6 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lane_type;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t quality;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t model_degree;

    /**
     * Range: -32768..32767 (-128..127.99609375 meters)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t position;

    /**
     * Range: 0..65535 (-0.031999023438..0.032000032767 1/meters)
     * Scale: 9.76563e-07
     * Offset: -0.031999023438
     */
    uint16_t curvature;

    /**
     * Range: 0..65535.00000000013421772799863 (-0.00012206658721..0.000122070312502198 1/meter^2)
     * Scale: 3.7252902985e-09
     * Offset: -0.00012206658721
     */
    uint16_t curvature_derivative;

    /**
     * Range: 0..255 (0..2.55 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t width_right_marking;
};

/**
 * Signals in message LKA_Left_Lane_A.
 *
 * All signal values are as on the CAN bus.
 */
struct ext_log_data_lka_left_lane_a_t {
    /**
     * Range: 0..6 (0..6 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lane_type;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t quality;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t model_degree;

    /**
     * Range: -32768..32767 (-128..127.99609375 meters)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t position;

    /**
     * Range: 0..65535 (-0.031999023438..0.032000032767 1/meters)
     * Scale: 9.76563e-07
     * Offset: -0.031999023438
     */
    uint16_t curvature;

    /**
     * Range: 0..65535.00000000013421772799863 (-0.00012206658721..0.000122070312502198 1/meter^2)
     * Scale: 3.7252902985e-09
     * Offset: -0.00012206658721
     */
    uint16_t curvature_derivative;

    /**
     * Range: 0..255 (0..2.55 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t width_right_marking;
};

/**
 * Signals in message Lane_Details.
 *
 * All signal values are as on the CAN bus.
 */
struct ext_log_data_lane_details_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t position_in_lanes;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t number_of_lanes;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t left_guard_rail;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t right_guard_rail;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t construction_area;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t right_ldw_availability;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t left_ldw_availability;

    /**
     * Range: 0..65534.94244610946759195259292 (-31.999..32 radians)
     * Scale: 0.000976563
     * Offset: -31.999
     */
    uint16_t yaw_angle;

    /**
     * Range: 0..65535.09404285995150403040828 (-0.05..0.05 radians)
     * Scale: 1.5259e-06
     * Offset: -0.05
     */
    uint16_t pitch_angle;
};

/**
 * Signals in message ObstacleDataC.
 *
 * All signal values are as on the CAN bus.
 */
struct ext_log_data_obstacle_data_c_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 degree)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t obstacle_angle_rate;

    /**
     * currently not in use
     * always zero
     *
     * Range: -32767..32767 (-6.5534..6.5534 pix/sec)
     * Scale: 0.0002
     * Offset: 0
     */
    int16_t obstacle_scale_change;

    /**
     * The longitude acceleration of the object.
     * Type: 10 bit, signed integer
     * Range: -14.97 : 14.97 [m/s2]
     * Conversion: (HEX)* 0.03
     * Invalid value: 200h
     *
     * Range: -499..499 (-14.97..14.97 m/s square)
     * Scale: 0.03
     * Offset: 0
     */
    int16_t object_accel_x;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t obstacle_replaced;

    /**
     * Range: -32768..32768 (-327.68..327.68 degree)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t obstacle_angle;
};

/**
 * Signals in message ObstacleDataB.
 *
 * All signal values are as on the CAN bus.
 */
struct ext_log_data_obstacle_data_b_t {
    /**
     * Range: 0..63 (0..31.5 m)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t obstacle_lenght;

    /**
     * Range: 0..250 (0..12.5 m)
     * Scale: 0.05
     * Offset: 0
     */
    uint8_t obstacle_width;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t obstacle_age;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t obstacle_lane;

    /**
     * 0 - not CIPV
     * 1 - CIPV
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cipv_flag;

    /**
     * Range: 0..4095.008 (0..255.938 m)
     * Scale: 0.0625
     * Offset: 0
     */
    uint16_t radar_pos_x;

    /**
     * Range: -2048..2048 (-128..128 m/sec)
     * Scale: 0.0625
     * Offset: 0
     */
    int16_t radar_vel_x;

    /**
     * Range: 0..5 (0..5 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t radar_match_confidence;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t matched_radar_id;
};

/**
 * Signals in message ObstacleDataA.
 *
 * All signal values are as on the CAN bus.
 */
struct ext_log_data_obstacle_data_a_t {
    /**
     * New obstacles are given the last used free ID
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t obstacle_id;

    /**
     * Range: 0..4000 (0..250 m)
     * Scale: 0.0625
     * Offset: 0
     */
    uint16_t obstacle_pos_x;

    /**
     * Range: -512..511 (-32..31.9375 m)
     * Scale: 0.0625
     * Offset: 0
     */
    int16_t obstacle_pos_y;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t blinker_info;

    /**
     * The signal is based on our estimation of where the target is now relatively to the lanes, its rate of change, and our estimation of where it is going to be within one second.
     * 
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cut_in_and_out;

    /**
     * Range: -2046.88..2046.88 (-127.93..127.93 m/sec)
     * Scale: 0.0625
     * Offset: 0
     */
    int16_t obstacle_vel_x;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t obstacle_type;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t obstacle_status;

    /**
     * 0 = off or not identifined
     * 1 = on
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t obstacle_brake_lights;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t obstacle_valid;
};

/**
 * Pack message LKA_Right_Lane_B.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ext_log_data_lka_right_lane_b_pack(
    uint8_t *dst_p,
    const struct ext_log_data_lka_right_lane_b_t *src_p,
    size_t size);

/**
 * Unpack message LKA_Right_Lane_B.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ext_log_data_lka_right_lane_b_unpack(
    struct ext_log_data_lka_right_lane_b_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ext_log_data_lka_right_lane_b_heading_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lka_right_lane_b_heading_angle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lka_right_lane_b_heading_angle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ext_log_data_lka_right_lane_b_view_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lka_right_lane_b_view_range_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lka_right_lane_b_view_range_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_lka_right_lane_b_view_range_availability_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lka_right_lane_b_view_range_availability_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lka_right_lane_b_view_range_availability_is_in_range(uint8_t value);

/**
 * Pack message LKA_Left_Lane_B.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ext_log_data_lka_left_lane_b_pack(
    uint8_t *dst_p,
    const struct ext_log_data_lka_left_lane_b_t *src_p,
    size_t size);

/**
 * Unpack message LKA_Left_Lane_B.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ext_log_data_lka_left_lane_b_unpack(
    struct ext_log_data_lka_left_lane_b_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ext_log_data_lka_left_lane_b_heading_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lka_left_lane_b_heading_angle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lka_left_lane_b_heading_angle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ext_log_data_lka_left_lane_b_view_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lka_left_lane_b_view_range_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lka_left_lane_b_view_range_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_lka_left_lane_b_view_range_availability_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lka_left_lane_b_view_range_availability_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lka_left_lane_b_view_range_availability_is_in_range(uint8_t value);

/**
 * Pack message LKA_Right_Lane_A.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ext_log_data_lka_right_lane_a_pack(
    uint8_t *dst_p,
    const struct ext_log_data_lka_right_lane_a_t *src_p,
    size_t size);

/**
 * Unpack message LKA_Right_Lane_A.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ext_log_data_lka_right_lane_a_unpack(
    struct ext_log_data_lka_right_lane_a_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_lka_right_lane_a_lane_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lka_right_lane_a_lane_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lka_right_lane_a_lane_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_lka_right_lane_a_quality_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lka_right_lane_a_quality_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lka_right_lane_a_quality_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_lka_right_lane_a_model_degree_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lka_right_lane_a_model_degree_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lka_right_lane_a_model_degree_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t ext_log_data_lka_right_lane_a_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lka_right_lane_a_position_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lka_right_lane_a_position_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ext_log_data_lka_right_lane_a_curvature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lka_right_lane_a_curvature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lka_right_lane_a_curvature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ext_log_data_lka_right_lane_a_curvature_derivative_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lka_right_lane_a_curvature_derivative_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lka_right_lane_a_curvature_derivative_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_lka_right_lane_a_width_right_marking_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lka_right_lane_a_width_right_marking_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lka_right_lane_a_width_right_marking_is_in_range(uint8_t value);

/**
 * Pack message LKA_Left_Lane_A.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ext_log_data_lka_left_lane_a_pack(
    uint8_t *dst_p,
    const struct ext_log_data_lka_left_lane_a_t *src_p,
    size_t size);

/**
 * Unpack message LKA_Left_Lane_A.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ext_log_data_lka_left_lane_a_unpack(
    struct ext_log_data_lka_left_lane_a_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_lka_left_lane_a_lane_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lka_left_lane_a_lane_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lka_left_lane_a_lane_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_lka_left_lane_a_quality_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lka_left_lane_a_quality_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lka_left_lane_a_quality_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_lka_left_lane_a_model_degree_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lka_left_lane_a_model_degree_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lka_left_lane_a_model_degree_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t ext_log_data_lka_left_lane_a_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lka_left_lane_a_position_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lka_left_lane_a_position_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ext_log_data_lka_left_lane_a_curvature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lka_left_lane_a_curvature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lka_left_lane_a_curvature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ext_log_data_lka_left_lane_a_curvature_derivative_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lka_left_lane_a_curvature_derivative_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lka_left_lane_a_curvature_derivative_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_lka_left_lane_a_width_right_marking_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lka_left_lane_a_width_right_marking_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lka_left_lane_a_width_right_marking_is_in_range(uint8_t value);

/**
 * Pack message Lane_Details.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ext_log_data_lane_details_pack(
    uint8_t *dst_p,
    const struct ext_log_data_lane_details_t *src_p,
    size_t size);

/**
 * Unpack message Lane_Details.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ext_log_data_lane_details_unpack(
    struct ext_log_data_lane_details_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_lane_details_position_in_lanes_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lane_details_position_in_lanes_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lane_details_position_in_lanes_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_lane_details_number_of_lanes_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lane_details_number_of_lanes_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lane_details_number_of_lanes_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_lane_details_left_guard_rail_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lane_details_left_guard_rail_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lane_details_left_guard_rail_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_lane_details_right_guard_rail_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lane_details_right_guard_rail_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lane_details_right_guard_rail_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_lane_details_construction_area_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lane_details_construction_area_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lane_details_construction_area_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_lane_details_right_ldw_availability_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lane_details_right_ldw_availability_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lane_details_right_ldw_availability_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_lane_details_left_ldw_availability_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lane_details_left_ldw_availability_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lane_details_left_ldw_availability_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ext_log_data_lane_details_yaw_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lane_details_yaw_angle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lane_details_yaw_angle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ext_log_data_lane_details_pitch_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_lane_details_pitch_angle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_lane_details_pitch_angle_is_in_range(uint16_t value);

/**
 * Pack message ObstacleDataC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ext_log_data_obstacle_data_c_pack(
    uint8_t *dst_p,
    const struct ext_log_data_obstacle_data_c_t *src_p,
    size_t size);

/**
 * Unpack message ObstacleDataC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ext_log_data_obstacle_data_c_unpack(
    struct ext_log_data_obstacle_data_c_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t ext_log_data_obstacle_data_c_obstacle_angle_rate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_obstacle_data_c_obstacle_angle_rate_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_obstacle_data_c_obstacle_angle_rate_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t ext_log_data_obstacle_data_c_obstacle_scale_change_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_obstacle_data_c_obstacle_scale_change_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_obstacle_data_c_obstacle_scale_change_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t ext_log_data_obstacle_data_c_object_accel_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_obstacle_data_c_object_accel_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_obstacle_data_c_object_accel_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_obstacle_data_c_obstacle_replaced_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_obstacle_data_c_obstacle_replaced_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_obstacle_data_c_obstacle_replaced_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t ext_log_data_obstacle_data_c_obstacle_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_obstacle_data_c_obstacle_angle_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_obstacle_data_c_obstacle_angle_is_in_range(int16_t value);

/**
 * Pack message ObstacleDataB.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ext_log_data_obstacle_data_b_pack(
    uint8_t *dst_p,
    const struct ext_log_data_obstacle_data_b_t *src_p,
    size_t size);

/**
 * Unpack message ObstacleDataB.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ext_log_data_obstacle_data_b_unpack(
    struct ext_log_data_obstacle_data_b_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_obstacle_data_b_obstacle_lenght_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_obstacle_data_b_obstacle_lenght_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_obstacle_data_b_obstacle_lenght_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_obstacle_data_b_obstacle_width_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_obstacle_data_b_obstacle_width_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_obstacle_data_b_obstacle_width_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_obstacle_data_b_obstacle_age_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_obstacle_data_b_obstacle_age_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_obstacle_data_b_obstacle_age_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_obstacle_data_b_obstacle_lane_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_obstacle_data_b_obstacle_lane_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_obstacle_data_b_obstacle_lane_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_obstacle_data_b_cipv_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_obstacle_data_b_cipv_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_obstacle_data_b_cipv_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ext_log_data_obstacle_data_b_radar_pos_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_obstacle_data_b_radar_pos_x_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_obstacle_data_b_radar_pos_x_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t ext_log_data_obstacle_data_b_radar_vel_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_obstacle_data_b_radar_vel_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_obstacle_data_b_radar_vel_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_obstacle_data_b_radar_match_confidence_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_obstacle_data_b_radar_match_confidence_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_obstacle_data_b_radar_match_confidence_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_obstacle_data_b_matched_radar_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_obstacle_data_b_matched_radar_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_obstacle_data_b_matched_radar_id_is_in_range(uint8_t value);

/**
 * Pack message ObstacleDataA.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ext_log_data_obstacle_data_a_pack(
    uint8_t *dst_p,
    const struct ext_log_data_obstacle_data_a_t *src_p,
    size_t size);

/**
 * Unpack message ObstacleDataA.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ext_log_data_obstacle_data_a_unpack(
    struct ext_log_data_obstacle_data_a_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_obstacle_data_a_obstacle_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_obstacle_data_a_obstacle_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_obstacle_data_a_obstacle_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ext_log_data_obstacle_data_a_obstacle_pos_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_obstacle_data_a_obstacle_pos_x_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_obstacle_data_a_obstacle_pos_x_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t ext_log_data_obstacle_data_a_obstacle_pos_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_obstacle_data_a_obstacle_pos_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_obstacle_data_a_obstacle_pos_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_obstacle_data_a_blinker_info_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_obstacle_data_a_blinker_info_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_obstacle_data_a_blinker_info_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_obstacle_data_a_cut_in_and_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_obstacle_data_a_cut_in_and_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_obstacle_data_a_cut_in_and_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t ext_log_data_obstacle_data_a_obstacle_vel_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_obstacle_data_a_obstacle_vel_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_obstacle_data_a_obstacle_vel_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_obstacle_data_a_obstacle_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_obstacle_data_a_obstacle_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_obstacle_data_a_obstacle_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_obstacle_data_a_obstacle_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_obstacle_data_a_obstacle_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_obstacle_data_a_obstacle_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_obstacle_data_a_obstacle_brake_lights_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_obstacle_data_a_obstacle_brake_lights_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_obstacle_data_a_obstacle_brake_lights_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ext_log_data_obstacle_data_a_obstacle_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ext_log_data_obstacle_data_a_obstacle_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ext_log_data_obstacle_data_a_obstacle_valid_is_in_range(uint8_t value);


#ifdef __cplusplus
}
#endif

#endif
