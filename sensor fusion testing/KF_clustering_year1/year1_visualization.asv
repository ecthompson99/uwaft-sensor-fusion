%[scenario, sensors, egoCar] = generateScenario1();
logFilename = "ACCGapTestLong_20191103_160048_CAN.mat"; %CAN Log .mat File to load

tracker = multiObjectTracker('FilterInitializationFcn', @initKF, ...
    'AssignmentThreshold', 27, 'ConfirmationParameters', [4 5]);
positionSelector = [1 0 0 0; 0 0 1 0]; % Position selector
velocitySelector = [0 1 0 0; 0 0 0 1]; % Velocity selector

% Create the display and return a handle to the bird's-eye plot
%BEP = createDemoDisplay(egoCar, sensors);

% Add a lane boundary plotter within the scope of the main loop
%lbPlotter = laneBoundaryPlotter(BEP,'DisplayName', ...
%'Lane boundary detections','Color','green');

results = struct('Time',[],'Tracks', [], 'GroundTruth', []);
current_step = 1;

while advance(scenario) && ishghandle(BEP.Parent)
    % Get the scenario time
    time = scenario.SimulationTime;
    % Get the position of the other vehicle in ego vehicle coordinates
    ta = targetPoses(egoCar);
    lookaheadDistance = 0:0.5:60;
    lb = laneBoundaries(egoCar,'XDistance', ...
        lookaheadDistance,'LocationType','inner');
    
    [detections, laneDets, isValidTime, isValidLaneTime] = ... 
        simulateSensors(sensors, ta, time, lb, false);

    % Update the tracker if there are new detections
    if any(isValidTime)
        vehicleLength = sensors{1}.ActorProfiles.Length;
        detectionObjects = clusterDetections(detections, vehicleLength);
        confirmedTracks = updateTracks(tracker, detectionObjects, time);

        % Update bird's-eye plot
        updateBEP(BEP, egoCar, detectionObjects, confirmedTracks, ... 
            positionSelector, velocitySelector);
    end
    
    % Update BEP lane detections
    if isValidLaneTime
        plotLaneBoundary(lbPlotter,vertcat(laneDets.LaneBoundaries));
    end
    
    % Save all data into a struct so the values can be checked after the
    % simulation
    results(current_step).Time = time;
    results(current_step).Tracks = confirmedTracks;
    temp = [scenario.Actors(1,1).Position];
    % For ground truth we only want to consider vehicles that can actually
    % be detctected bt the vehcile. So we ensure they are within range
    % before adding them to the struct
    for i = 2:4
        dist = norm(egoCar.Position(1:2) - scenario.Actors(1,i).Position(1:2));
        if dist <= 80
            temp = [temp; scenario.Actors(1,i).Position]; %#ok
        end
    end
    results(current_step).GroundTruth = temp;
    current_step = current_step + 1;
end 

calcBinaryClassification(results, current_step);